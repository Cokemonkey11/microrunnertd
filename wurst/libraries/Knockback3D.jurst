/**
 * Knockback3D by Cokemonkey11, a projectile motion emulator for unit knockback effects.
 *
 * Requirements:
 *		Optional IsDestructableTree
 * 			Supports both PitzerMike's (http://goo.gl/zZHhGc) and BPower's (http://goo.gl/jGYFQK)
 *			implementation. Use one or none.
 *
 *		IsTerrainWalkable or TerrainPathability
 * 			To more accurately detect collisions, you must have either IsTerrainWalkable by Anitarf
 *			and Vexorian (http://goo.gl/bf1wpN) OR TerrainPathability by Rising_Dusk
 *			(http://goo.gl/UTzPdG).
 *
 * API:
 * 		constant boolean USE_MOVESPEED_MODIFIERS - Prevent a unit from moving while airborne
 *      constant boolean USE_TREE_CHECKER - Check destructables for trees only before destroying
 *      constant boolean DESTROY_DESTRUCTABLES_ONHIT - Destroy destructables hit by projectiles
 *		constant real CLOCK_PERIOD - how often to iterate through projectile bodies
 *		constant real COEFF_RESTITUTION_GROUND - Fraction of velocity to keep after hitting ground
 * 		constant real COEFF_RESTITUTION_DSTRBL - Fraction of velocity to keep after hitting destruc.
 * 		constant real FRICTION_ITER_MULTIPLIER - Fraction of velocity to lose while sliding per ite.
 *		constant real GRAVITY - Acceleration rate in units per second per second
 * 		constant real MAX_Z_VELOCITY_TO_BOUNCE - The necessary z-velocity to bounce off ground
 *		constant real MIN_Z_VELOCITY_TO_BECOME_AIRBORNE - necessay z-velocity to stop sliding
 * 		constant real MIN_FLY_HEIGHT - A height threshold (for floating units)
 *		constant real MIN_FOR_KNOCKBACK - Minimum velocity to maintain knockback (units / second)
 *		constant real MIN_SPEED_FRICTION_FX - The minimum speed to draw friction FX
 *		constant string FRICTION_MODEL - The FX to draw during high-friction sliding.
 *		constant real DESTRUCTABLE_ENUM_RADIUS - Size of square to enumerate destructables.
 *		constant real MIN_VEL_DESTROY_DESTRUCTABLE - Minimum velocity to destroy destructable
 * 		constant real MAX_HEIGHT_DESTROY_DESTRUCTABLE - The flying height at which destru. destroyed
 *
 *		Knockback3D.updateMapArea(rect r)
 *		Knockback3D.add(unit,real a, real b, real c) - Apply vector of size a to unit towards b on
 *			the XY plane, and c on the Z axis.
 *		Knockback3D.setVel(unit,real a, real b, real c) - Set unit's knockback vector to a towards b
 *			on the XY plan and c on the Z axis.
 */
library Knockback3D
	import IsTerrainWalkable

	// <<===========================================================================================
	// Begin Customizable Section
	// <<===========================================================================================
	globals
		/**
		 * Defines whether units should have their movespeed set to 0 and then back to "default"
		 * speed. If false, units in mid air can still fully control themselves. Warning: This is
		 * not a lock-safe crowd-control implementation.
		 */
        constant boolean USE_MOVESPEED_MODIFIERS=true

		/**
		 * Defines whether the script should check enumerated destructables as being trees or not.
		 * If enabled, will only work if IsDestructableTree library is available.
		 */
		constant boolean USE_TREE_CHECKER=false

		/**
		 * Defines whether to enumerate and destroy destructables in contact with projectile bodies.
		 */
		constant boolean DESTROY_DESTRUCTABLES_ONHIT=false
	end

	/**
	 * Object which holds knockback data, not to be modified by the client.
	 */
    struct Knockback3D

		/**
		 * A parameter for controlling the system clock, in seconds. 1/30 runs 30 times per second.
		 */
        private static constant real CLOCK_PERIOD=1./30.

		/**
		 * A measure of velocity retention after colliding with ground. 0.4 means 40% retention.
		 */
        private static constant real COEFF_RESTITUTION_GROUND=.2

		/**
		 * How much velocity should be retained after hitting a destructable. A value of .3 means
		 * 30% velocity is retained.
		 */
        private static constant real COEFF_RESTITUTION_DSTRBL=.3

		/**
		 * What fraction of velocity should be lost with every iteration of ground friction. Note
		 * that simulating an abstraction of friction in units per second overflows real precision
		 * numbers. Thus, you must adjust this according to your clock period.
		 */
        private static constant real FRICTION_ITER_MULTIPLIER=.15

		/**
		 * The downward acceleration of units in motion. A value of CLOCK_PERIOD*41.25 means they
		 * accelerate downwards by 41.25 game units per second.
		 */
        private static constant real GRAVITY=CLOCK_PERIOD*45.

		/**
		 * The minimum fall-speed for a unit to bounce. CLOCK_PERIOD*-300. means that the a unit
		 * must be falling at 300 units per second to bounce.
		 */
        private static constant real MAX_Z_VELOCITY_TO_BOUNCE=CLOCK_PERIOD*-300.

		/**
		 * The minimum z-velocity of a unit to actually have it's flying height changed, instead of
		 * simply sliding. Note: This may need refactoring in combination with
		 * MAX_Z_VELOCITY_TO_BOUNCE
		 */
        private static constant real MIN_Z_VELOCITY_TO_BECOME_AIRBORNE=CLOCK_PERIOD*150.

		/**
		 * This is the minimum height a unit can be at before friction is applied. Recommend a value
		 * greater than 0 as floating units have a small non-zero value.
		 */
        private static constant real MIN_FLY_HEIGHT=5.

		/**
		 * The minimum horizontal velocity a unit can be sliding before the system ignores it. A
		 * value of CLOCK_PERIOD*30 means the unit will stop sliding when its slide speed reduces
		 * past 30 units per second.
		 */
        private static constant real MIN_FOR_KNOCKBACK=CLOCK_PERIOD*30.

		/**
		 * The minimum speed a sliding unit must be moving to spawn a "friction" special effect. A
		 * value of CLOCK_PERIOD*180 means the effect is applied while units are moving faster than
		 * 180 game units per second.
		 */
        private static constant real MIN_SPEED_FRICTION_FX=CLOCK_PERIOD*180.

		/**
		 * The model to spawn when a unit's horizontal velocity > MIN_SPEED_FRICTION_FX
		 */
        private static constant string FRICTION_MODEL="Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl"

		/**
		 * The square size to search for destructables when destroying them. Note that a square's
		 * diagonal is Sqrt(2) times bigger than this.
		 */
        private static constant real DESTRUCTABLE_ENUM_RADIUS=130.

		/**
		 * This is the minimum horizontal velocity a unit must have to destroy a destructable. You
		 * can set this to a very high number to disable the feature. A value of CLOCK_PERIOD*300
		 * means the unit must travel at 300 units per second on the XY plane, to destroy obstacles.
		 */
        private static constant real MIN_VEL_DESTROY_DESTRUCTABLE=CLOCK_PERIOD*300.

		/**
		 * The height below which a unit in the stack is elligible to destroy a destructable.
		 * Ideally it should be the average height of your destructables.
		 */
        private static constant real MAX_HEIGHT_DESTROY_DESTRUCTABLE=150.

		// =======================================================================================>>
		// End Customizable Section
		// =======================================================================================>>

		/**
		 * The raw ID of crow form, which allows ground units to have adjusted fly-height.
		 */
        private static constant integer CROW_ID='Arav'

		/**
		 * Flag used for reference when a destructable has been hit/destroyed.
		 */
        private static boolean hitDestructable

		/**
		 * A stack size reference
		 */
        private static integer dbIndex=-1

		/**
		 * Stack of KnockDat references
		 */
        private static thistype array knockDB

		/**
		 * Temp object for the getZ shim
		 */
        private static location zLoc=Location(0.,0.)

		/**
		 * A reference to the map's minimum x co-ordinate
		 */
        private static real mapMinX

		/**
		 * A reference to the map's maximum x co-ordinate
		 */
        private static real mapMaxX

		/**
		 * A reference to the map's minimum y co-ordinate
		 */
        private static real mapMinY

		/**
		 * A reference to the map's maximum y co-ordinate
		 */
        private static real mapMaxY

		/**
		 * A static rect used to enumerate destructables
		 */
        private static rect destructableRect

		/**
		 * The static system clock
		 */
        private static timer clock=CreateTimer()

		private static real gravity = GRAVITY

		static method setGravity takes real r returns nothing
			gravity = CLOCK_PERIOD * r
		endmethod

		/**
		 * A simple shim for getting the z heigh of a co-ordinate pair.
		 */
		private static method getZ takes real x, real y returns real
			call MoveLocation(zLoc,x,y)
			return GetLocationZ(zLoc)
		endmethod

		/**
		 * The callback function when enumerating destructables
		 */
		private static method destructableCallback takes nothing returns nothing
			local destructable des=GetEnumDestructable()
			if GetDestructableLife(des)>0. then
				hitDestructable=true
			endif
		endmethod

		/**
		 * The periodic function which iterates through all objects in flight
		 */
		private static method p takes nothing returns nothing
			local boolean newInMap
			local integer index=0
			local real flyHeight
			local real unitX
			local real unitY
			local real heightDifference
			local real newX
			local real newY
			local real velXY
			local thistype tempDat
			loop
				exitwhen index>dbIndex
				tempDat=knockDB[index]
				unitX=GetUnitX(tempDat.u)
				unitY=GetUnitY(tempDat.u)
				newX=unitX+tempDat.delX
				newY=unitY+tempDat.delY
				newInMap=newX>mapMinX and newX<mapMaxX and newY>mapMinY and newY<mapMaxY
				flyHeight=GetUnitFlyHeight(tempDat.u)
				velXY=(tempDat.delX*tempDat.delX+tempDat.delY*tempDat.delY)
				if flyHeight<MIN_FLY_HEIGHT then
					if isTerrainWalkable(newX,newY) and newInMap then
						call SetUnitX(tempDat.u,unitX+tempDat.delX)
						call SetUnitY(tempDat.u,unitY+tempDat.delY)
						if tempDat.delZ<=MIN_FLY_HEIGHT then
							tempDat.delX=tempDat.delX*(1.-FRICTION_ITER_MULTIPLIER)
							tempDat.delY=tempDat.delY*(1.-FRICTION_ITER_MULTIPLIER)
							if velXY>MIN_SPEED_FRICTION_FX then
								call DestroyEffect(AddSpecialEffect(FRICTION_MODEL,unitX,unitY))
							endif
						endif
						static if USE_MOVESPEED_MODIFIERS then
							call SetUnitMoveSpeed(tempDat.u,GetUnitDefaultMoveSpeed(tempDat.u))
						endif
					else
						tempDat.delX=0
						tempDat.delY=0
					endif

					if tempDat.delZ<MAX_Z_VELOCITY_TO_BOUNCE then
						tempDat.delZ=tempDat.delZ*-1.*COEFF_RESTITUTION_GROUND
					endif
					if tempDat.delZ>MIN_Z_VELOCITY_TO_BECOME_AIRBORNE then
						call SetUnitFlyHeight(tempDat.u,flyHeight+tempDat.delZ,0)
						tempDat.delZ=tempDat.delZ-gravity
					endif
				elseif newInMap then
					tempDat.delZ=tempDat.delZ-gravity
					heightDifference=getZ(newX,newY)-getZ(unitX,unitY)
					call SetUnitFlyHeight(tempDat.u,flyHeight+tempDat.delZ-heightDifference,0)
					call SetUnitX(tempDat.u,newX)
					call SetUnitY(tempDat.u,newY)
					static if USE_MOVESPEED_MODIFIERS then
						call SetUnitMoveSpeed(tempDat.u,0)
					endif
				endif
				if velXY<MIN_FOR_KNOCKBACK and tempDat.delZ>MAX_Z_VELOCITY_TO_BOUNCE and tempDat.delZ<-1*MAX_Z_VELOCITY_TO_BOUNCE and flyHeight<MIN_FLY_HEIGHT then
					knockDB[index]=knockDB[dbIndex]
					dbIndex=dbIndex-1
					call SetUnitFlyHeight(tempDat.u,0,0)
					static if USE_MOVESPEED_MODIFIERS then
						call SetUnitMoveSpeed(tempDat.u,GetUnitDefaultMoveSpeed(tempDat.u))
					endif
					destroy tempDat
					index=index-1
					if dbIndex<0 then
						call PauseTimer(clock)
					endif
				endif
				if velXY>MIN_VEL_DESTROY_DESTRUCTABLE and flyHeight<MAX_HEIGHT_DESTROY_DESTRUCTABLE then
					hitDestructable=false
					call MoveRectTo(destructableRect,newX,newY)
					call EnumDestructablesInRect(destructableRect,null,function destructableCallback)
					if hitDestructable then
						tempDat.delX=tempDat.delX*COEFF_RESTITUTION_DSTRBL
						tempDat.delY=tempDat.delY*COEFF_RESTITUTION_DSTRBL
					endif
				endif
				index=index+1
			endloop
		endmethod

		/**
		 * Gets the unit's stack index using linear search. Adding optional Table could potentially be
		 * useful.
		 */
		private static method getUnitIndexFromStack takes unit u returns integer
			local integer index=0
			local integer returner=-1
			local thistype tempDat
			loop
				exitwhen index>dbIndex or returner!=-1
				tempDat=knockDB[index]
				if tempDat.u==u then
					returner=index
				endif
				index=index+1
			endloop
			return returner
		endmethod

		/**
		 * Initialization function
		 */
		private static method onInit takes nothing returns nothing
			destructableRect=Rect(-1*DESTRUCTABLE_ENUM_RADIUS,-1*DESTRUCTABLE_ENUM_RADIUS,DESTRUCTABLE_ENUM_RADIUS,DESTRUCTABLE_ENUM_RADIUS)
			mapMinX=GetRectMinX(bj_mapInitialPlayableArea)
			mapMaxX=GetRectMaxX(bj_mapInitialPlayableArea)
			mapMinY=GetRectMinY(bj_mapInitialPlayableArea)
			mapMaxY=GetRectMaxY(bj_mapInitialPlayableArea)
		endmethod

		/**
		 * A function for updating the valid map co-ordinates, in case the playable map area changes
		 * dynamically.
		 */
		static method updateMapArea takes rect rct returns nothing
			mapMinX=GetRectMinX(rct)
			mapMinY=GetRectMinY(rct)
			mapMaxX=GetRectMaxX(rct)
			mapMaxY=GetRectMaxY(rct)
		endmethod

		/**
		 * Add a knockback vector to a unit. If the unit is already in the system, the new vector
		 * will be emulated as a secondary knockback source.
		 *
		 * Parameters:
		 *		u: unit to knock back
		 * 		velocity: speed in units per second at which to knock the unit back
		 *  	angle: The angle on the XY plane to knock the unit, in radians.
		 *		alpha: The angle of attack (z-axis) to knock the unit, in radians (where 0 is no AoA)
		 */
		static method add takes unit u, real velocity, real angle, real alpha returns nothing
			local integer index=getUnitIndexFromStack(u)
			local thistype tempDat
			local real instVel=velocity*CLOCK_PERIOD
			if index==-1 then
				tempDat = new Knockback3D
				tempDat.u=u
				tempDat.delX=instVel*Cos(angle)*Cos(alpha)
				tempDat.delY=instVel*Sin(angle)*Cos(alpha)
				tempDat.delZ=instVel*Sin(alpha)
				dbIndex=dbIndex+1
				knockDB[dbIndex]=tempDat
				if UnitAddAbility(tempDat.u,CROW_ID) then
					call UnitRemoveAbility(tempDat.u,CROW_ID)
				endif
				if dbIndex==0 then
					call TimerStart(clock,CLOCK_PERIOD,true,function p)
				endif
			else
				tempDat=knockDB[index]
				tempDat.delX=tempDat.delX+instVel*Cos(angle)*Cos(alpha)
				tempDat.delY=tempDat.delY+instVel*Sin(angle)*Cos(alpha)
				tempDat.delZ=tempDat.delZ+instVel*Sin(alpha)
			endif
		endmethod

		/**
		 * Set the knockback vector of a unit. If the unit is already in the system, the new vector
		 * will replace the old one.
		 *
		 * Parameters:
		 *		u: unit to knock back
		 * 		velocity: speed in units per second at which to knock the unit back
		 *  	angle: The angle on the XY plane to knock the unit, in radians.
		 *		alpha: The angle of attack (z-axis) to knock the unit, in radians (where 0 is no AoA)
		 */
		static method setVel takes unit u, real velocity, real angle, real alpha returns nothing
			local integer index=getUnitIndexFromStack(u)
			local thistype tempDat
			local real instVel=velocity*CLOCK_PERIOD
			if index==-1 then
				tempDat = new Knockback3D
				tempDat.u=u
				tempDat.delX=instVel*Cos(angle)*Cos(alpha)
				tempDat.delY=instVel*Sin(angle)*Cos(alpha)
				tempDat.delZ=instVel*Sin(alpha)
				dbIndex=dbIndex+1
				knockDB[dbIndex]=tempDat
				if UnitAddAbility(tempDat.u,CROW_ID) then
					call UnitRemoveAbility(tempDat.u,CROW_ID)
				endif
				if dbIndex==0 then
					call TimerStart(clock,CLOCK_PERIOD,true,function p)
				endif
			else
				tempDat=knockDB[index]
				tempDat.delX=instVel*Cos(angle)*Cos(alpha)
				tempDat.delY=instVel*Sin(angle)*Cos(alpha)
				tempDat.delZ=instVel*Sin(alpha)
			endif
		endmethod

		static method getVel takes unit u returns real
			local integer index = getUnitIndexFromStack(u)
			local thistype tempDat
			local real v
			if index != -1 then
				tempDat = knockDB[index]
				v = tempDat.delX * tempDat.delX + tempDat.delY * tempDat.delY + tempDat.delZ * tempDat.delZ
				return SquareRoot(v)
			endif
			return 0.
		endmethod

		// Instance Variables
		/**
		 * The unit being knocked back
		 */
        private unit u

		/**
		 * The knockback vector's x-component
		 */
        private real delX

		/**
		 * The knockback vector's y-component
		 */
        private real delY

		/**
		 * The knockback vector's z-component
		 */
        private real delZ
    endstruct
end
